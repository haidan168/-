# JavaScript 高级

## 基础

### 1. 数据类型判断

- typeof
  - 可以判断：undefined、string、number、Boolean、function
  - 不能判断：**null和object、array和object**
- instanceof
  - 判断对象的具体类型
- ===
  - 可以判断：undefined、null
- undefined与null的区别：
  - undefined代表定义未赋值
  - null定义并赋值了, 只是值为null
- 什么时候给变量赋值为null：
  - 初始赋值, 表明将要赋值为对象
  - 结束前, 让对象成为垃圾对象(被垃圾回收器回收)
- 严格区别变量类型与数据类型：
  - 变量类型：
    - 基本类型
    - 引用类型（保存的是地址值）
  - 数据类型：
    - 基本类型
    - 对象类型

### 2. 数据 变量 内存

- 数据：
  - 存储在内存中代表特定信息的东西，本质上是0101...
  - 数据的特点：可传递、可运算
  - 内存中所有操作的目标: 数据
- 变量：
  - 可变化的量, 由变量名和变量值组成
  - 每个变量都对应的一块小内存, 变量名用来查找对应的内存, 变量值就是内存中保存的数据
- 内存：
  - 内存条通电后产生的可储存数据的空间(临时的)
  - 内存产生和死亡: 内存条(电路版)==>通电==>产生内存空间==>存储数据==>处理数据==>断电==>内存空间和数据都消失
  - 内存中有两种数据：
    1. 基本数据
    2. 地址值数据
  - 内存分类
    - 栈内存：全局变量/局部变量
    - 堆内存：对象
- 内存,数据, 变量三者之间的关系：
  - 内存用来存储数据的空间
  - 变量是内存的标识
- var a = x x x, a内存中到底保存的是：
  - x x x是基本数据, 保存的就是这个数据
  - x x x是对象, 保存的是对象的地址值
  - x x x是一个变量, 保存的是x x x的内存中的内容(可能是基本数据, 也可能是地址值)

- 关于引用变量赋值问题：
  - 2个引用变量指向同一个对象, 通过一个变量修改对象内部数据, 另一个变量看到的是修改之后的数据
  - 2个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象, 另一引用变量依然指向前一个对象

- 在js调用函数时传递变量参数时, 是值传递还是引用传递
  - 理解1: 都是值(基本/地址值)传递
  - 理解2: 可能是值传递, 也可能是引用传递(地址值)

- JS引擎如何管理内存：
  - 内存生命周期：
    - 分配小内存空间, 得到它的使用权
    - 存储数据, 可以反复进行操作
    - 释放小内存空间
  - 释放内存
    - 局部变量: 函数执行完自动释放
    - 对象: 成为垃圾对象==>垃圾回收器回收

### 4. 对象

- 什么是对象：
  - 多个数据的封装体
  - 用来保存多个数据的容器
  - 一个对象代表现实中的一个事物
- 对象的作用：
  - 统一管理多个数据
- 对象的组成
  - 属性: 属性名(字符串)和属性值(任意)组成
  - 方法: 一种特别的属性(属性值是函数)
- 访问对象内部的数据：
  - .属性名: 编码简单, 有时不能用
  - ['属性名']: 编码麻烦, 能通用
    - 属性名包含特殊字符: - 空格
    - 属性名不确定

### 5. 函数

- 什么是函数?
  - 实现特定功能的n条语句的封装体
  - 只有函数是可以执行的, 其它类型的数据不能执行
- 函数的作用：
  - 提高代码复用
  - 便于阅读交流
- 定义函数
  - 函数声明
  - 表达式

```
// 函数声明
function fun(){
}
```

```
// 表达式
var fun = function(){
}
```

- 调用(执行)函数
  - test(): 直接调用
  - obj .test(): 通过对象调用
  - new test(): new调用
  - test .call/apply(obj): 临时让test成为obj的方法进行调用
    - 可以让一个函数成为指定任意对象的方法进行调用

### 6. 回调函数

- 什么函数才是回调函数?
  - 定义了
  - 但没有调用
  - 最后函数执行了（在某个时刻或某个条件下)
- 常见的回调函数
  - dom事件回调函数 ==>发生事件的dom元素
  - 定时器回调函数 ===>window
  - ajax请求回调函数
  - 生命周期回调函数

### 7. IIFE

- 全称: Immediately-Invoked Function Expression
  - 匿名函数自调用
- 作用：
  - 隐藏实现
  - 不会污染外部(全局)命名空间
  - 用它来编码js模块

### 8. 函数中的this

- this是什么？
  - 任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window
  - 所有函数内部都有一个变量this
  - 它的值是调用函数的当前对象
- 如何确定this的值?
  - test(): window
  - p. test(): p
  - new test(): 新创建的对象
  - p. call(obj): obj

## 函数高级

#### 1. 原型与原型链

- 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)
- 原型对象中有一个属性constructor, 它指向函数对象
- 作用: 函数的所有实例对象自动拥有原型中的属性(方法)

**显式原型和隐式原型**：

- 每个函数function都有一个prototype，即显式原型(属性)
- 每个实例对象都有一个\__proto__，可称为隐式原型(属性)
- 对象的隐式原型的值为其对应构造函数的显式原型的值
- 函数的prototype属性: 在定义函数时自动添加的, 默认值是一个空Object对象
- 对象的\__proto__属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值

**原型链**：

- 访问一个对象的属性时，先在自身属性中查找，找到返回，如果没有, 再沿着\__proto__这条链向上查找, 找到返回，最终没找到, 返回undefined
- 别名: 隐式原型链
- 作用: 查找对象的属性(方法)
- 函数的显示原型指向的对象默认是空Object实例对象(但Object不满足)
  - Object的原型对象是原型链尽头
- 所有函数都是Function的实例(包含Function)

**原型链的属性：**

- 读取对象的属性值时: 会自动到原型链中查找
- 设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值
- 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上

**instanceof：**

- instanceof是如何判断的?
  - 表达式: A instanceof B
  - **如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false**

#### 2. 执行上下文与执行上下文栈

**变量提升和函数提升：**

- 变量声明提升
  - 通过var定义(声明)的变量, 在定义语句之前就可以访问到
  - 值: undefined
- 函数声明提升
  - 通过function声明的函数, 在之前就可以直接调用
  - 值: 函数定义(对象)
- **先执行变量提升, 再执行函数提升**

**执行上下文：**

- 代码分类(位置)
  - 全局代码
  - 函数(局部)代码
- 全局执行上下文
  - 在执行全局代码前将window确定为全局执行上下文
  - 对全局数据进行预处理
    - var定义的全局变量==>undefined, 添加为window的属性
    - function声明的全局函数==>赋值(fun), 添加为window的方法
    - this==>赋值(window)
  - 开始执行全局代码
- 函数执行上下文
  - 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象(虚拟的, 存在于栈中)
  - 对局部数据进行预处理
    - 形参变量==>赋值(实参)==>添加为执行上下文的属性
    - arguments==>赋值(实参列表), 添加为执行上下文的属性
    - var定义的局部变量==>undefined, 添加为执行上下文的属性
    - function声明的函数 ==>赋值(fun), 添加为执行上下文的方法
    - this==>赋值(调用函数的对象)
  - 开始执行函数体代码

**执行上下文栈：**

- 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象
- 在全局执行上下文(window)确定后, 将其添加到栈中(压栈)
- 在函数执行上下文创建后, 将其添加到栈中(压栈)
- 在当前函数执行完后,将栈顶的对象移除(出栈)
- 当所有的代码执行完后, 栈中只剩下window

#### 3. 作用域与作用域链

**作用域：**

- 就是一块"地盘", 一个代码段所在的区域
- 它是静态的(相对于上下文对象), 在编写代码时就确定了
- 分类：
  - 全局作用域
  - 函数作用域
  - 块作用域(ES 6)
- 作用：
  - 隔离变量，不同作用域下同名变量不会有冲突

**作用域和执行上下文：**

- 区别1：
  - 全局作用域之外，每个函数都会创建自己的作用域，**作用域在函数定义时就已经确定了。**而不是在函数调用时
  - 全局执行上下文环境是在全局作用域确定之后, **js代码马上执行之前创建**
- 区别2：
  - 作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化
  - 执行上下文是动态的, 调用函数时创建, 函数调用结束时就会自动释放
- 联系：
  - 执行上下文(对象)是从属于所在的作用域
  - 全局上下文环境==>全局作用域
  - 函数上下文环境==>对应的函数使用域

**作用域链：**

- 多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外)
- 查找变量时就是沿着作用域链来查找的
- 查找一个变量的查找规则：
  - 在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入2
  - 在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入3
  - 再次执行2的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常

#### 4. 闭包

- 如何产生闭包?
  - 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包
- 闭包是什么：
  - 函数的内部函数中包含引用（外部）函数数据(变量/函数)）的对象

**闭包产生的条件:**

- 函数嵌套
- 内部函数引用了外部函数的数据(变量/函数)

**闭包的作用：**

- 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)

- 让函数外部可以操作(读写)到函数内部的数据(变量/函数)

- 函数执行完后，函数内部声明的局部变量一般是不存在的，但是存在于闭包中的变量可能存在
- 在函数外部不能直接访问函数内部的局部变量，但是可以通过闭包让外部操作它

**常见的闭包：**

- 将函数作为另一个函数的返回值
- 将函数作为实参传递给另一个函数调用

**闭包的生命周期：**

- 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)
- 死亡: 在嵌套的内部函数成为垃圾对象时

## 对象高级

#### 1. 对象创建模型

- Object构造函数模式
  - 先创建空Object对象, 再动态添加属性/方法
  - 适用场景: 起始时不确定对象内部数据
  - 问题: 语句太多

```
var obj = new Object();
obj.name = "hebe";
obj.number = 330;
obj.setName = function(){
	this.name = name;
}
```

- 对象字面量模式
  - 使用{}创建对象, 同时指定属性/方法
  - 适用场景: 起始时对象内部数据是确定的
  - 问题: 如果创建多个对象, 有重复代码

```
var obj = {
	name: "hebe",
	number: 330,
	setName: function(){
		this.name = name;
	}
}
```

- 工厂模式
  - 通过工厂函数动态创建对象并返回
  - 需要创建多个对象
  - 对象没有一个具体的类型, 都是Object类型

```
function createperson(name,number){
	var obj ={
		name: name,
		number: number,
		setName: function(){
			this.name = name;
		}
	}
	return obj;
}
var obj = new createperson("hebe",330);
```

- 自定义构造函数模式
  - 适用场景: 需要创建多个类型确定的对象
  - 问题: 每个对象都有相同的数据, 浪费内存

```
function Person(name,number){
	this.name = name;
	this.number = number;
	this.setName = function(name){
		this.name = name;
	}
}
var person = new Person("hebe",330);
```

- 构造函数+原型的组合模式
  - 套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上
  - 适用场景: 需要创建多个类型确定的对象

```
function Person(name,number){
	this.name = name;
	this.number = number;
}
Person.prototype.setName = function(name){
	this.name = name;
}
var person = new Person("hebe",330);
```

#### 2. 继承模式

- 原型链继承
  - 步骤：
    1. 定义父类型构造函数
    2. 给父类型的原型添加方法
    3. 定义子类型的构造函数
    4. 创建父类型的对象赋值给子类型的原型
    5. 将子类型原型的构造属性设置为子类型
    6. 给子类型原型添加方法
    7. 创建子类型的对象: 可以调用父类型的方法
- **子类型的原型为父类型的一个实例对象**

```
function Super(){
	this.superName = "Super";
}
Super.prototype.showSuper= function(){
	console.log(this.superName);
}
function Sub(){
	this.subName = "Sub";
}
Sub.prototype = new Super();
Sub.constructor = Sub;
Sub.prototype.showSub(){
	console.log(this.subName)
}
var sub = new Sub();
sub.showSub();
sub.showSuper();
```

- 借用构造函数继承(假的)
  - 步骤：
    1. 定义父类型构造函数
    2. 定义子类型构造函数
    3. 在子类型构造函数中调用父类型构造
- **在子类型构造函数中通用call()调用父类型构造函数**

```
function Person(name, age) {
  this.name = name
  this.age = age
}
function Student(name, age, price) {
  Person.call(this, name, age)  // 相当于:    this.Person(name, age)
  this.price = price
}
var s = new Student('Tom', 20, 14000)
console.log(s.name, s.age , s.price)
```

- 原型链+借用构造函数的组合继承
  - 利用原型链实现对父类型对象的方法继承
  - 利用call()借用父类型构建函数初始化相同属性

```
function Person(name, age) {
  this.name = name
  this.age = age
}
Person.prototype.setName = function (name) {
  this.name = name
}

function Student(name, age, price) {
  Person.call(this, name, age)  // 为了得到属性
  this.price = price
}
Student.prototype = new Person() // 为了能看到父类型的方法
Student.prototype.constructor = Student //修正constructor属性
Student.prototype.setPrice = function (price) {
  this.price = price
}

var s = new Student('Tom', 24, 15000)
s.setName('Bob')
s.setPrice(16000)
console.log(s.name, s.age, s.price)
```

## 线程机制和事件机制

### 1. 进程与线程

- 进程
  - 程序的一次执行，占有一片独有的内存空间
  - 可以通过windows任务管理器查看进程
- 线程
  - 是进程内的一个独立单元
  - 是程序执行的一个完整流程
  - 是CPU的最小的调度单元
- 应用程序必须在某个进程的某个线程上
- 一个进程中至少有一个运行的线程：主线程，进程启动后自动创建
- 一个进程中也可以同时运行多个线程，会说程序时多线程运行的
- 一个进程内的数据可以供其中的多个线程直接共享
- 多个进程之间的数据是不能直接共享的
- 线程池：保存多个线程对象的容器，实现线程对象的反复利用

- 多进程和多线程
  - 多进程运行：一个应用程序可以同时启动多个实例运行
  - 多线程：在一个进程内，同时又多个线程运行
- 比较单线程和多线程
  - 多线程
    - 优点
      - 能有效提高CPU的利用率
    - 缺点
      - 创建多线程开销
      - 线程间切换开销
      - 死锁与状态同步问题
  - 单线程
    - 优点
      - 顺序编程简单
    - 缺点
      - 效率低
- js是单线程还是多线程
  - js是单线程运行的
  - 但是使用H 5中的Web Workers可以多线程运行
- 浏览器运行时单线程还是多线程
  - 浏览器都是多线程运行的
- 浏览器运行时单进程还是多进程
  - Chrome 是多进程 

